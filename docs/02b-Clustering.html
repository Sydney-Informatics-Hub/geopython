<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>02b-Clustering.utf8.md</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/simplex.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="lesson.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 41px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h2 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h3 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h4 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h5 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h6 {
  padding-top: 46px;
  margin-top: -46px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Home</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Setup
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="setup.html">Setup</a>
    </li>
    <li>
      <a href="AWSinstuctionsStudents.html">AWS Backup instructions</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Session 1
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="00-intro.html">Introduction</a>
    </li>
    <li>
      <a href="01a-fundamentals.html">Fundamentals</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Session 2
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="01b-dataframes.html">Useful Python packages for different data types</a>
    </li>
    <li>
      <a href="02a-mapping.html">Mapping with Cartopy</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Session 3
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="03a-MachineLearning.html">Machine Learning</a>
    </li>
    <li>
      <a href="03b-DeepLearningTS.html">Deep Learning &amp; Time Series</a>
    </li>
    <li>
      <a href="02b-Clustering.html">Numerical approaches</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Session 4
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="04a-SimpleSpeedUps.html">Simple Speed Ups</a>
    </li>
    <li>
      <a href="04b-DaskDataframes.html">Dask data frames</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<div id="numerical-analysis" class="section level1">
<h1>Numerical analysis</h1>
<div id="questions" class="section level3 questions">
<h3>Questions</h3>
<ul>
<li>What computational/numercal techniques can be performed in Python?</li>
<li>What tools are availble for analysis?</li>
<li>How can I learn more information about my data?</li>
</ul>
</div>
<div id="objectives" class="section level3 objectives">
<h3>Objectives</h3>
<ul>
<li>Generate a numerical model.</li>
<li>Interpolate missing data.</li>
<li>Run the scikit-learn k-means algorithm.</li>
<li>Plot 3D data.</li>
</ul>
</div>
<div id="numerical-models" class="section level2">
<h2>Numerical models</h2>
<p>We start with the numerical solution of a very simple differential equation. In fact we choose something simple enough that we already know the answer.</p>
<div align="center">
<p><span class="math inline">\(\frac{d\theta}{dt} = - k \theta\)</span></p>
</div>
<p>This is the equation which governs radioactive decay, in which case <span class="math inline">\(\theta\)</span> is the amount of the radioactive isotope remaining and <span class="math inline">\(d\theta / dt\)</span> is the activity that we can measure. <span class="math inline">\(k\)</span> is closely related to the half life.</p>
The solution to this equation is
<div align="center">
<p><span class="math inline">\(\theta(t) = \theta_0 e^{-kt}\)</span></p>
</div>
<p>where <span class="math inline">\(\theta_0\)</span> is the amount of the radioactive material remaining. The same equation also describes the cooling of, say, a cup of coffee. In this case we interpret <span class="math inline">\(\theta\)</span> as the excess temperature (above room temperature).</p>
<pre class="python"><code>import numpy as np
import matplotlib.pyplot as plt

#Set the amount of isotope remaining (i.e. 1=100%)
theta_0 = 1.0

#Create a regularly spaced vector of time values
#20 units between 0 and 1.
steps=20
timelength=1.0
time_values = np.linspace(0,timelength,steps)

#Try several different values for the half-life, k
for const_k in [1.0, 3.1, 10.0, 31, 100.0]:
    #This is the solution to the decay equation, how much isotope remains.
    exact_theta_values = theta_0 * np.exp(-const_k * time_values)
    #Plot the results for different k values
    plt.plot(time_values, exact_theta_values)
    
#Add some plot flair    
plt.legend((&#39;1&#39;, &#39;3.1&#39;, &#39;10&#39;, &#39;31&#39;, &#39;1000&#39;),title=r&#39;$k$&#39;)
plt.xlabel(&#39;time&#39;)
plt.ylabel(r&#39;$\theta$&#39;)
plt.show()</code></pre>
<div class="figure">
<img src="02b-Clustering_files/02b-Clustering_2_0.png" alt="" />
<p class="caption">png</p>
</div>
<p>We want to be able to march forward in time from our starting point (just like the picture above) where <span class="math inline">\(\theta = \theta_0\)</span> to obtain the value of <span class="math inline">\(\theta\)</span> at later times. To do this, we need to approximate the original differential equation, and, in particular, the value of the time derivative at each time. There are a number of ways to do this.</p>
<div id="first-order-numerical-approximation" class="section level3">
<h3>First order numerical approximation</h3>
Assume that the variation in <span class="math inline">\(\theta(t)\)</span> is linear, i.e.
<div align="center">
<p><span class="math inline">\(\theta(t&#39;) = \theta_n + \beta t&#39;\)</span></p>
</div>
<p>where we use a local time coordinate <span class="math inline">\(t&#39; = t - n\Delta t\)</span>, so that when we differentiate</p>
<div align="center">
<p><span class="math inline">\(\frac{d \theta}{dt} = \beta\)</span></p>
</div>
<p>To determine the approximation for the derivative therefore becomes the solution to the following equation:</p>
<div align="center">
<p><span class="math inline">\(\theta_{n+1} = \theta_n + \beta \Delta t\)</span></p>
<p><span class="math inline">\(\Rightarrow \beta = \frac{d \theta}{dt} = \frac{\theta_{n+1} - \theta_n}{\Delta t}\)</span></p>
</div>
<p>This is a first order difference expression for the derivative which we substitute into the original differential equation for radioactive decay at the current timestep</p>
<div align="center">
<p><span class="math inline">\(\frac{\theta_{n+1} - \theta_n}{\Delta t} = - k \theta_n\)</span></p>
</div>
<p>This rearranges to give us a time-marching algorithm:</p>
<div align="center">
<p><span class="math inline">\(\theta_{n+1} = \theta_n (1-k \Delta t)\)</span></p>
</div>
<p>In a moment we will compute some values for this expression to see how accurate it is.</p>
<pre class="python"><code>#Set the known constant values
theta_0 = 1.0
const_k = 10.0
#How many timesteps to solve
steps = 20
timelength = 1.0
delta_t = timelength / steps

#Create a regularly spaced vector of time values
time_values = np.linspace(0,timelength,steps)

#Create an empty array to store the solutions
theta_values = np.zeros(steps)

#Set the starting values
theta_values[0] = theta_0

#Step through the time values
for i in range(1, steps):
    #Find the value for theta at this time step
    theta_values[i] = theta_values[i-1] * (1 - const_k * delta_t)

#Compare with the exact solution
exact_theta_values = theta_0 * np.exp(-const_k * time_values)

#Plot and compare your results
plt.plot(time_values, theta_values, linewidth=3.0, color=&quot;red&quot;)
plt.plot(time_values, exact_theta_values, &#39;b-&#39;)
</code></pre>
<pre><code>[&lt;matplotlib.lines.Line2D at 0x1f928a62308&gt;]</code></pre>
<div class="figure">
<img src="02b-Clustering_files/02b-Clustering_4_1.png" alt="" />
<p class="caption">png</p>
</div>
</div>
<div id="second-order-runge-kutta" class="section level3">
<h3>Second Order Runge-Kutta</h3>
<p>The Runge-Kutta method can be a more accurate approach to higher order integration solutions. The idea is to estimate the gradient \(d / d t\) at the half way point between two timestep values. This is done in two stages. Initially a first order estimate, \(  \) is made for the value of the function \( \) at \(t=t+t /2\) in the future. This value is then subsituted into the differential equation to obtain the estimate for the gradient at this time. The revised gradient is then used to update the original \((t)\) by an entire timestep.</p>
<p>The first order step is <span class="math display">\[
        \begin{split}
        \hat{\theta}(t+\Delta t /2) &amp; = \theta(t) + \left.  \frac{d \theta}{d t} \right|_t \frac{\Delta t}{2} \\
         &amp;= \theta(t) \left[ 1-\frac{k\Delta t}{2} \right]
        \end{split}
\]</span></p>
<p>Substitute to estimate the gradient at the mid-point <span class="math display">\[
    \left. \frac{d \theta}{d t} \right|_{t+\Delta t /2} \approx -k \theta(t)  \left[ 1-\frac{k\Delta t}{2} \right]
\]</span></p>
<p>Use this value as the average gradient over the interval <span class="math inline">\(t\rightarrow t+\Delta t\)</span> to update \(\)</p>
<div align="center">
<p><span class="math inline">\(\theta(t+\Delta t) \approx \theta(t) + \delta t \left( -k \theta(t) \left[ 1-\frac{k\Delta t}{2} \right] \right)\)</span></p>
</div>
Which gives the Second Order Runge-Kutta estimation for updated <span class="math inline">\(\theta\)</span> values:
<div align="center">
<p><span class="math inline">\(\theta(t+\Delta t) \approx \theta(t) \left( 1 - k \Delta t + k^2 \frac{\Delta t^2}{2} \right)\)</span></p>
</div>
</div>
<div id="challenge" class="section level3 challenge">
<h3>Challenge</h3>
<ul>
<li>Can you implement the Second Order Runge-Kutta Numerical Solution in Python? Start as before:</li>
</ul>
<pre class="python"><code>#Set the known constant values
theta_0 = 1.0
const_k = 10.0
#How many timesteps to solve
steps = 20
timelength = 1.0
delta_t = timelength / steps

#Create a regularly spaced vector of time values
time_values = np.linspace(0,timelength,steps)

#Create an empty array to store the solutions
theta_values = np.zeros(steps)

#Set the starting values
theta_values[0] = theta_0

#Step through the time values
for i in range(1, steps):
    #Find the value for theta at this time step
    theta_values[????] = ????

#Compare with the exact solution
exact_theta_values = theta_0 * np.exp(-const_k * time_values)

#Plot and compare your results
plt.plot(time_values, theta_values, linewidth=3.0, color=&quot;red&quot;)
plt.plot(time_values, exact_theta_values, &#39;b-&#39;)</code></pre>
<details>
<summary>
Solution
</summary>
<p>This is my solution</p>
<pre class="python"><code>theta_0 = 1.0
const_k = 10.0
steps = 20
timelength = 1.0
delta_t = timelength / steps

time_values = np.linspace(0,timelength,steps)

theta_values = np.zeros(steps)

theta_values[0] = theta_0

for i in range(1, steps):
    theta_values[i] = theta_values[i-1] * (1 - const_k * delta_t + const_k**2 * delta_t**2 / 2.0)

exact_theta_values = theta_0 * np.exp(-const_k * time_values)

plt.plot(time_values, theta_values, linewidth=3.0, color=&quot;red&quot;)
plt.plot(time_values, exact_theta_values, &#39;b-&#39;)</code></pre>
</details>
</div>
</div>
<div id="scipy.interpolate" class="section level2">
<h2>scipy.interpolate</h2>
<p>This module provides general interpolation capability for data in 1, 2, and higher dimensions. This list of features is from the documentation:</p>
<ul>
<li><p>A class representing an interpolant (interp1d) in 1-D, offering several interpolation methods.</p></li>
<li><p>Convenience function griddata offering a simple interface to interpolation in N dimensions (N = 1, 2, 3, 4, …). Object-oriented interface for the underlying routines is also available.</p></li>
<li><p>Functions for 1- and 2-dimensional (smoothed) cubic-spline interpolation, based on the FORTRAN library FITPACK. There are both procedural and object-oriented interfaces for the FITPACK library.</p></li>
<li><p>Interpolation using Radial Basis Functions.</p></li>
</ul>
<pre class="python"><code>import matplotlib.pyplot as plt
import numpy as np</code></pre>
<div id="d-data" class="section level3">
<h3>1D data</h3>
<pre class="python"><code>from scipy.interpolate import interp1d</code></pre>
<pre class="python"><code>x = np.linspace(0, 10, num=11, endpoint=True)
y = np.cos(-x**2/9.0)
f = interp1d(x, y, kind=&#39;linear&#39;) # default if kind=None
f2 = interp1d(x, y, kind=&#39;cubic&#39;)
f3 = interp1d(x, y, kind=&#39;nearest&#39;)</code></pre>
<pre class="python"><code>xnew = np.linspace(0, 10, num=41, endpoint=True)
plt.plot(x, y, &#39;o&#39;, xnew, f(xnew), &#39;-&#39;, xnew, f2(xnew), &#39;--&#39;, xnew, f3(xnew), &#39;.-&#39;)
plt.legend([&#39;data&#39;, &#39;linear&#39;, &#39;cubic&#39;, &#39;nearest&#39;], loc=&#39;best&#39;)
plt.show()</code></pre>
<div class="figure">
<img src="02b-Clustering_files/02b-Clustering_12_0.png" alt="" />
<p class="caption">png</p>
</div>
</div>
<div id="nd-data" class="section level3">
<h3>nD data</h3>
<p>There are fewer approaches to n-dimensional data, the evaluation for arbitrary dimensions is always for points on an n dimensional grid.</p>
<pre class="python"><code>from scipy.interpolate import griddata

def func(x, y):
    return x*(1-x)*np.cos(4*np.pi*x) * np.sin(4*np.pi*y**2)**2</code></pre>
<pre class="python"><code># A regular grid array of x,y coordinates

grid_x, grid_y = np.mgrid[0:1:100j, 0:1:200j] # see np.info(np.mgrid) for an explanation of the 200j !!</code></pre>
<pre class="python"><code>np.info(np.mgrid)</code></pre>
<pre><code>`nd_grid` instance which returns a dense multi-dimensional &quot;meshgrid&quot;.

An instance of `numpy.lib.index_tricks.nd_grid` which returns an dense
(or fleshed out) mesh-grid when indexed, so that each returned argument
has the same shape.  The dimensions and number of the output arrays are
equal to the number of indexing dimensions.  If the step length is not a
complex number, then the stop is not inclusive.

However, if the step length is a **complex number** (e.g. 5j), then
the integer part of its magnitude is interpreted as specifying the
number of points to create between the start and stop values, where
the stop value **is inclusive**.

Returns
----------
mesh-grid `ndarrays` all of the same dimensions

See Also
--------
numpy.lib.index_tricks.nd_grid : class of `ogrid` and `mgrid` objects
ogrid : like mgrid but returns open (not fleshed out) mesh grids
r_ : array concatenator

Examples
--------
&gt;&gt;&gt; np.mgrid[0:5,0:5]
array([[[0, 0, 0, 0, 0],
        [1, 1, 1, 1, 1],
        [2, 2, 2, 2, 2],
        [3, 3, 3, 3, 3],
        [4, 4, 4, 4, 4]],
       [[0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4]]])
&gt;&gt;&gt; np.mgrid[-1:1:5j]
array([-1. , -0.5,  0. ,  0.5,  1. ])</code></pre>
<pre class="python"><code># A random sampling within the same area
points = np.random.rand(1000, 2)
values = func(points[:,0], points[:,1])

# Resample from the values at these points onto the regular mesh
grid_z0 = griddata(points, values, (grid_x, grid_y), method=&#39;nearest&#39;)
grid_z1 = griddata(points, values, (grid_x, grid_y), method=&#39;linear&#39;)
grid_z2 = griddata(points, values, (grid_x, grid_y), method=&#39;cubic&#39;)</code></pre>
<pre class="python"><code>plt.subplot(221)
plt.imshow(func(grid_x, grid_y).T, extent=(0,1,0,1), origin=&#39;lower&#39;, cmap=&#39;jet&#39;)
plt.plot(points[:,0], points[:,1], &#39;k.&#39;, ms=1)
plt.title(&#39;Original&#39;)
plt.subplot(222)
plt.imshow(grid_z0.T, extent=(0,1,0,1), origin=&#39;lower&#39;, cmap=&#39;jet&#39;)
plt.title(&#39;Nearest&#39;)
plt.subplot(223)
plt.imshow(grid_z1.T, extent=(0,1,0,1), origin=&#39;lower&#39;, cmap=&#39;jet&#39;)
plt.title(&#39;Linear&#39;)
plt.subplot(224)
plt.imshow(grid_z2.T, extent=(0,1,0,1), origin=&#39;lower&#39;, cmap=&#39;jet&#39;)
plt.title(&#39;Cubic&#39;)
plt.gcf().set_size_inches(6, 6)
plt.show()</code></pre>
<div class="figure">
<img src="02b-Clustering_files/02b-Clustering_18_0.png" alt="" />
<p class="caption">png</p>
</div>
</div>
<div id="splines" class="section level3">
<h3>Splines</h3>
<p>Which have the added benefit of giving smooth derivative information</p>
<pre class="python"><code>from scipy.interpolate import splrep, splev</code></pre>
<pre class="python"><code>x = np.arange(0, 2*np.pi+np.pi/4, 2*np.pi/8)
y = np.sin(x)
tck = splrep(x, y, s=0)
xnew = np.arange(0, 2*np.pi, np.pi/50)
ynew = splev(xnew, tck, der=0)
yder = splev(xnew, tck, der=1)</code></pre>
<pre class="python"><code>plt.figure()
plt.plot(x, y, &#39;x&#39;, xnew, ynew, xnew, np.sin(xnew), x, y, &#39;b&#39;)
plt.legend([&#39;Linear&#39;, &#39;Cubic Spline&#39;, &#39;True&#39;])
plt.axis([-0.05, 6.33, -1.05, 1.05])
plt.title(&#39;Cubic-spline interpolation&#39;)
plt.show()</code></pre>
<div class="figure">
<img src="02b-Clustering_files/02b-Clustering_22_0.png" alt="" />
<p class="caption">png</p>
</div>
<pre class="python"><code>plt.figure()
plt.plot(xnew, yder, xnew, np.cos(xnew),&#39;--&#39;)
plt.legend([&#39;Cubic Spline&#39;, &#39;True&#39;])
plt.axis([-0.05, 6.33, -1.05, 1.05])
plt.title(&#39;Derivative estimation from spline&#39;)
plt.show()</code></pre>
<div class="figure">
<img src="02b-Clustering_files/02b-Clustering_23_0.png" alt="" />
<p class="caption">png</p>
</div>
<p><strong>2D splines</strong> are also available</p>
<pre class="python"><code>from scipy.interpolate import bisplrep, bisplev

# Gridded function (at low resolution ... doesn&#39;t need to be gridded data here)

x, y = np.mgrid[-1:1:20j, -1:1:20j]
z = (x+y) * np.exp(-6.0*(x*x+y*y))

plt.figure()
plt.pcolor(x, y, z, cmap=&#39;jet&#39;,shading=&#39;auto&#39;)
plt.colorbar()
plt.title(&quot;Sparsely sampled function.&quot;)
plt.show()</code></pre>
<div class="figure">
<img src="02b-Clustering_files/02b-Clustering_25_0.png" alt="" />
<p class="caption">png</p>
</div>
<pre class="python"><code>xnew, ynew = np.mgrid[-1:1:70j, -1:1:70j]

## Create the spline-representation object tck

tck = bisplrep(x, y, z, s=0)
znew = bisplev(xnew[:,0], ynew[0,:], tck)</code></pre>
<pre class="python"><code>plt.figure()
plt.pcolor(xnew, ynew, znew, cmap=&#39;jet&#39;,shading=&#39;auto&#39;)
plt.colorbar()
plt.title(&quot;Interpolated function.&quot;)
plt.show()</code></pre>
<div class="figure">
<img src="02b-Clustering_files/02b-Clustering_27_0.png" alt="" />
<p class="caption">png</p>
</div>
</div>
<div id="see-also" class="section level3">
<h3>See also</h3>
<ul>
<li>Radial basis function interpolation for scattered data in n dimensions (slow for large numbers of points): <code>from scipy.interpolate import Rbf</code></li>
<li><code>scipy.ndimage</code> for fast interpolation operations on image-like arrays</li>
<li>B-splines on regular arrays are found in the <code>scipy.signal</code> module</li>
</ul>
</div>
</div>
<div id="clustering-data-with-scikit-learn" class="section level2">
<h2>Clustering data with scikit-learn</h2>
<p>Here we want to explore a neat and efficient way of exploring a (seisimic tomography) dataset in Python. We will be using a Machine Learning algorithm known as <a href="https://scikit-learn.org/stable/modules/clustering.html#k-means">K-Means clustering</a>.</p>
<p>Data is from: <em>Li, C., van der Hilst, R. D., Engdahl, E. R., and Burdick, S. (2008), A new global model for P wave speed variations in Earth’s mantle, Geochem. Geophys. Geosyst., 9, Q05018, <a href="doi:10.1029/2007GC001806" class="uri">doi:10.1029/2007GC001806</a></em></p>
<pre class="python"><code>from sklearn.cluster import KMeans
import numpy as np
import matplotlib.pyplot as plt 
from mpl_toolkits.mplot3d import Axes3D</code></pre>
<p>Load in the tomography data set. Assign the column vectors to unique variables (for clarity).</p>
<pre class="python"><code>tomo=np.loadtxt(&#39;../data/ggge1202-sup-0002-ds01.txt&#39;, skiprows=1)

lat=tomo[:,0]
lon=tomo[:,1]
depth=tomo[:,2]
dvp=tomo[:,3]</code></pre>
<p>Now run the clustering algorithm</p>
<pre class="python"><code>kmeans = KMeans(n_clusters=5, random_state=0).fit(dvp.reshape(-1, 1))

#When completed, check the clusters the algorithm has identified.
print(kmeans.cluster_centers_)</code></pre>
<pre><code>[[-0.03368738]
 [ 3.92812009]
 [ 0.27602101]
 [ 1.8442656 ]
 [-0.2770305 ]]</code></pre>
<p>Note, many functions have been “parallelised” and tuned to best take advantage of your computer, see e.g. for more details <a href="https://scikit-learn.org/stable/modules/computing.html#parallelism">https://scikit-learn.org/stable/modules/computing.html#parallelism</a></p>
<p>You can have a look what the labels look like. It is essentially a vector the same length as the data indicating which label it has classified.</p>
<pre class="python"><code>kmeans.labels_</code></pre>
<pre><code>array([3, 3, 3, ..., 0, 0, 0])</code></pre>
<p>Choose one of the clusters to visualise, so subset the data into new vectors accordingly</p>
<pre class="python"><code>centre=3

latClust=lat[kmeans.labels_==centre]
lonClust=lon[kmeans.labels_==centre]
depthClust=depth[kmeans.labels_==centre]
dvpClust=dvp[kmeans.labels_==centre]</code></pre>
<p>Finally, plot the results!</p>
<pre class="python"><code>fig = plt.figure()
ax = fig.add_subplot(111, projection=&#39;3d&#39;)
ax.scatter(lonClust, latClust, -depthClust, c=dvpClust)</code></pre>
<pre><code>&lt;mpl_toolkits.mplot3d.art3d.Path3DCollection at 0x1f93d669648&gt;</code></pre>
<div class="figure">
<img src="02b-Clustering_files/02b-Clustering_40_1.png" alt="" />
<p class="caption">png</p>
</div>
<div id="key-points" class="section level3 keypoints">
<h3>Key points</h3>
<ul>
<li>You can use Python to solve math equations</li>
<li>scipy for interpolation</li>
<li>sklearn for clustering</li>
<li>New ways to plot data</li>
<li>Read the docs to learn more</li>
</ul>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
